# 좋아요 기능 요구사항 분석

## 1️⃣ 문제 상황 재정의

### 📱 사용자 관점
**문제:** 사용자가 마음에 드는 상품을 저장하고 나중에 다시 찾아보고 싶다.
- 상품 목록이나 상세 페이지를 볼 때, 관심 가는 상품을 빠르게 표시하고 싶음
- 내가 관심 표시한 상품들을 한 곳에서 모아보고 싶음
- 다른 사람들이 얼마나 좋아하는지 참고하고 싶음 (좋아요 수)

### 💼 비즈니스 관점
**문제:** 사용자의 관심사를 파악하고, 인기 상품을 식별하고 싶다.
- 어떤 상품이 인기 있는지 측정 가능해야 함
- 사용자의 관심 데이터를 수집하여 추후 추천 시스템 등에 활용 가능해야 함
- 좋아요 수를 통해 상품의 사회적 증거(Social Proof)를 제공하고 싶음

### 🖥️ 시스템 관점
**문제:** 좋아요 데이터의 일관성과 성능을 모두 고려해야 한다.
- 중복 좋아요를 방지해야 함
- 좋아요 수 집계는 실시간일 필요는 없지만, 크게 어긋나서는 안 됨
- 향후 트래픽 증가에 대비한 확장 가능한 구조여야 함 (Redis 등)

---

## 2️⃣ 개념 모델

### 액터 (Actors)
- **인증된 사용자 (Authenticated User)**
    - 좋아요를 등록/취소하는 주체
    - 자신의 좋아요 목록을 조회하는 주체

### 핵심 도메인 (Core Domain)
- **Product (상품)**
    - 좋아요의 대상이 되는 엔티티
    - 좋아요 개수 정보를 가짐

- **Like (좋아요)**
    - 사용자와 상품 간의 관계를 나타냄
    - 사용자 1명당 상품 1개에 대해 1개만 존재 가능

### 보조/외부 시스템
- **이벤트 시스템**
    - 좋아요 등록/취소 시 이벤트를 발행
    - 카운트 업데이트를 비동기로 처리

- **배치 시스템 (향후)**
    - 정합성 불일치 시 복구 담당
    - 이벤트 실패로 인한 데이터 불일치 보정

---

## 3️⃣ 명확화된 기능 요구사항

### FR-1. 좋아요 등록
**사용자 스토리:**  
사용자는 상품 목록 또는 상세 페이지에서 좋아요 버튼을 눌러 관심 상품을 표시할 수 있다.

**API 명세:**
```
POST /api/v1/products/{productId}/likes
Authorization: Required
```

**상세 동작:**
1. 인증된 사용자만 좋아요 등록 가능
2. 동일 사용자가 동일 상품에 대해 중복 좋아요 시도 시:
    - DB Unique 제약에 의해 실패
    - 클라이언트에 적절한 에러 응답 (409 Conflict 또는 400 Bad Request)
3. 좋아요 등록 성공 시:
    - `likes` 테이블에 데이터 저장
    - 이벤트 발행 (`LikeCreated`)
    - 비동기로 상품의 `like_count` 증가

**정책:**
- 좋아요 등록은 동기 처리 (즉시 응답)
- 카운트 업데이트는 비동기 처리 (Eventual Consistency)
- 이벤트 실패 시 재시도 없음, 배치로 정합성 복구

---

### FR-2. 좋아요 취소
**사용자 스토리:**  
사용자는 이미 누른 좋아요를 취소할 수 있다.

**API 명세:**
```
DELETE /api/v1/products/{productId}/likes
Authorization: Required
```

**상세 동작:**
1. 인증된 사용자만 좋아요 취소 가능
2. 존재하지 않는 좋아요에 대한 취소 요청 시:
    - 비정상적인 접근으로 간주
    - 에러 로그 기록
    - 클라이언트에는 성공 응답 (멱등성 보장)
3. 좋아요 취소 성공 시:
    - `likes` 테이블에서 데이터 삭제
    - 이벤트 발행 (`LikeDeleted`)
    - 비동기로 상품의 `like_count` 감소

**정책:**
- 좋아요 취소는 멱등성을 가짐 (여러 번 호출해도 결과 동일)
- 카운트 업데이트는 비동기 처리
- 이벤트 실패 시 재시도 없음, 배치로 정합성 복구

---

### FR-3. 내 좋아요 목록 조회
**사용자 스토리:**  
사용자는 자신이 좋아요한 상품 목록을 확인할 수 있다.

**API 명세:**
```
GET /api/v1/users/{userId}/likes
Authorization: Required
```

**상세 동작:**
1. 인증된 사용자만 조회 가능
2. URL의 `{userId}` 파라미터는 무시
3. 항상 로그인한 사용자의 좋아요 목록만 조회
4. 페이지네이션 지원 (추후 구체화 필요)

**정책:**
- 다른 사용자의 좋아요 목록은 조회 불가
- 권한 에러(403) 없음, URL userId는 참고용으로만 사용
- 향후 확장 가능성을 위해 URL 구조는 유지

**참고:**
- 현재는 본인 것만 조회하지만, URL 구조는 향후 "친구 좋아요 목록 보기" 등의 기능 확장을 염두

---

### FR-4. 좋아요 수 노출
**사용자 스토리:**  
사용자는 상품의 인기도를 파악하기 위해 좋아요 수를 확인할 수 있다.

**노출 위치:**
- 상품 목록 페이지
- 상품 상세 페이지

**상세 동작:**
1. 상품 조회 API 응답에 `like_count` 포함
2. 좋아요 등록/취소 직후에는 카운트가 바로 반영되지 않을 수 있음 (Eventual Consistency)
3. 향후 트래픽 증가 시 Redis로 전환 고려

**정책:**
- 좋아요 수는 정확하지 않아도 됨 (몇 초~몇 분 지연 허용)
- 대략적인 인기도 파악이 목적

---

## 4️⃣ 비기능 요구사항

### NFR-1. 성능
- 좋아요 등록/취소 API는 200ms 이내 응답 목표
- 동시 좋아요 시 DB 락 경합 최소화 (비동기 카운트 업데이트)

### NFR-2. 확장성
- 향후 Redis를 통한 카운트 캐싱 구조로 전환 가능해야 함
- 이벤트 기반 아키텍처로 다른 시스템과의 결합도 최소화

### NFR-3. 데이터 일관성
- 좋아요 데이터는 강한 일관성 (DB 제약)
- 좋아요 카운트는 최종 일관성 (Eventual Consistency)
- 배치를 통한 정합성 복구 메커니즘 필요

### NFR-4. 보안
- 모든 API는 인증 필수
- SQL Injection, XSS 등 기본 보안 위협 방어

---

## 5️⃣ 결정된 제약사항 및 전제조건

### 데이터 제약
- 사용자 1명당 상품 1개에 대해 좋아요 1개만 가능
    - DB Unique Index: `(user_id, product_id)`

### 아키텍처 결정
- **동기 처리:** 좋아요 등록/취소 (즉시 응답)
- **비동기 처리:** 카운트 업데이트 (이벤트 기반)
- **재시도 없음:** 이벤트 실패 시 로그만 남기고 배치로 복구

### 향후 확장 고려사항
- Redis 도입 (카운트 캐싱)
- 친구/타인의 좋아요 목록 조회 기능
- 좋아요 기반 추천 시스템

---

## 6️⃣ 다음 단계에서 다룰 내용

1. **시퀀스 다이어그램**
    - 좋아요 등록 시 트랜잭션 경계 확인
    - 이벤트 발행 및 비동기 처리 흐름
    - 실패 시나리오

2. **클래스 다이어그램**
    - Product, Like, User 간의 관계
    - 도메인 책임 분리
    - 의존 방향

3. **ERD**
    - 테이블 구조 및 관계
    - Unique 제약
    - 인덱스 전략

4. **설계 리스크 분석**
    - 이벤트 실패 시 정합성 불일치 리스크
    - 배치 복구 전략의 한계
    - 향후 확장 시 고려사항