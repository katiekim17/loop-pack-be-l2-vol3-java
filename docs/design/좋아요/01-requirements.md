## 좋아요 기능 상세 정의

### FR-1. 좋아요 등록
**사용자 스토리:**  
사용자는 상품 목록 또는 상세 페이지에서 좋아요 버튼을 눌러 관심 상품을 표시할 수 있다.

**API 명세:**
```
POST /api/v1/products/{productId}/likes
Authorization: Required
```

**상세 동작:**
1. 인증된 사용자만 좋아요 등록 가능
2. 동일 사용자가 동일 상품에 대해 중복 좋아요 시도 시:
    - DB Unique 제약에 의해 실패
    - 클라이언트에 적절한 에러 응답 (409 Conflict 또는 400 Bad Request)
3. 좋아요 등록 성공 시:
    - `likes` 테이블에 데이터 저장
    - 이벤트 발행 (`LikeCreated`)
    - 비동기로 상품의 `like_count` 증가
      
**정책:**
- 좋아요 등록은 동기 처리 (즉시 응답)
- 카운트 업데이트는 비동기 처리 (Eventual Consistency)
- 이벤트 실패 시 재시도 없음, 배치로 정합성 복구
- 좋아요 카운트전략은 "비정규화"로 만들어보기

**에러 처리:**
- 이미 좋아요한 상품 → 409 Conflict

---

### FR-2. 좋아요 취소
**사용자 스토리:**  
사용자는 이미 누른 좋아요를 취소할 수 있다.

**API 명세:**
```
DELETE /api/v1/products/{productId}/likes
Authorization: Required
```

**상세 동작:**
1. 인증된 사용자만 좋아요 취소 가능
2. 존재하지 않는 좋아요에 대한 취소 요청 시:
    - 비정상적인 접근으로 간주
    - 에러 로그 기록
    - 클라이언트에는 성공 응답 (멱등성 보장)
3. 좋아요 취소 성공 시:
    - `likes` 테이블에서 데이터 삭제
    - 이벤트 발행 (`LikeDeleted`)
    - 비동기로 상품의 `like_count` 감소
4. 멱등성 보장 (이미 취소된 좋아요 재요청 시 성공 응답)

**정책:**
- 좋아요 취소는 멱등성을 가짐 (여러 번 호출해도 결과 동일)
- 카운트 업데이트는 비동기 처리
- 이벤트 실패 시 재시도 없음, 배치로 정합성 복구

---

### FR-3. 내 좋아요 목록 조회
**사용자 스토리:**  
사용자는 자신이 좋아요한 상품 목록을 확인할 수 있다.

**API 명세:**
```
GET /api/v1/users/{userId}/likes
Authorization: Required
```

**상세 동작:**
1. 인증된 사용자만 조회 가능
2. URL의 `{userId}` 파라미터는 무시
3. 항상 로그인한 사용자의 좋아요 목록만 조회
4. 페이지네이션 지원 (추후 구체화 필요)

**Query Parameters:**
- `page` (선택, Integer, 기본값: 0): 페이지 번호
- `size` (선택, Integer, 기본값: 20): 페이지 크기

**반환 정보:**
```json
{
  "content": [
    {
      "productId": 1,
      "name": "상품명",
      "brand": {
        "brandId": 1,
        "name": "브랜드명"
      },
      "thumbnailImageUrl": "https://example.com/product-thumbnail.png",
      "minPrice": 10000,
      "likeCount": 150,
      "likedAt": "2025-01-15T10:30:00"
    }
  ],
  "page": 0,
  "size": 20,
  "totalElements": 10,
  "totalPages": 1
}
```

**정책:**
- 다른 사용자의 좋아요 목록은 조회 불가
- 권한 에러(403) 없음, URL userId는 참고용으로만 사용
- 향후 확장 가능성을 위해 URL 구조는 유지

**참고:**
- 현재는 본인 것만 조회하지만, URL 구조는 향후 "친구 좋아요 목록 보기" 등의 기능 확장을 염두

---

### FR-4. 좋아요 수 노출
**사용자 스토리:**  
사용자는 상품의 인기도를 파악하기 위해 좋아요 수를 확인할 수 있다.

**노출 위치:**
- 상품 목록 페이지
- 상품 상세 페이지

**상세 동작:**
1. 상품 조회 API 응답에 `like_count` 포함
2. 좋아요 등록/취소 직후에는 카운트가 바로 반영되지 않을 수 있음 (Eventual Consistency)
3. 향후 트래픽 증가 시 Redis로 전환 고려

**정책:**
- 좋아요 수는 정확하지 않아도 됨 (몇 초~몇 분 지연 허용)
- 대략적인 인기도 파악이 목적

---

## 비기능 요구사항

### NFR-1. 성능
- 좋아요 등록/취소 API는 200ms 이내 응답 목표
- 동시 좋아요 시 DB 락 경합 최소화 (비동기 카운트 업데이트)

### NFR-2. 확장성
- 향후 Redis를 통한 카운트 캐싱 구조로 전환 가능해야 함
- 이벤트 기반 아키텍처로 다른 시스템과의 결합도 최소화

### NFR-3. 데이터 일관성
- 좋아요 데이터는 강한 일관성 (DB 제약)
- 좋아요 카운트는 최종 일관성 (Eventual Consistency)
- 배치를 통한 정합성 복구 메커니즘 필요

### NFR-4. 보안
- 모든 API는 인증 필수
- SQL Injection, XSS 등 기본 보안 위협 방어

---

## 결정된 제약사항 및 전제조건

### 데이터 제약
- 사용자 1명당 상품 1개에 대해 좋아요 1개만 가능
    - DB Unique Index: `(user_id, product_id)`

### 아키텍처 결정
- **동기 처리:** 좋아요 등록/취소 (즉시 응답)
- **비동기 처리:** 카운트 업데이트 (이벤트 기반)
- **재시도 없음:** 이벤트 실패 시 로그만 남기고 배치로 복구

### 향후 확장 고려사항
- Redis 도입 (카운트 캐싱)
- 친구/타인의 좋아요 목록 조회 기능
- 좋아요 기반 추천 시스템


#### 좋아요 카운트 정합성
**현재 (v1):**
- 좋아요 등록/취소: 동기
- 카운트 업데이트: 비동기 (Eventual Consistency)

**잠재 리스크:**
- 이벤트 발행 실패 시 카운트 불일치
- 대량 좋아요 발생 시 카운트 업데이트 지연

**해결 방안:**
- 배치 작업을 통한 정합성 복구
- 향후 Redis 캐시 도입 (실시간 카운트)

**설계 시 주의사항:**
- 좋아요 수는 "대략적인 인기도" 지표로 사용
- 정확한 수치가 필요한 경우 실시간 COUNT 쿼리 사용